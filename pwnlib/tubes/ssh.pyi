from typing import Any, AnyStr, Callable
from typing_extensions import deprecated, TypeAlias
from os import StrOrBytesPath

from paramiko import SFTPClient, SSHClient, Transport

from pwnlib.context import LocalContext
from pwnlib.elf.corefile import Corefile
from pwnlib.elf.elf import ELF
from pwnlib.log import Logger, Progress, ValidLogLevel
from pwnlib.tubes.process import _ArgvType
from pwnlib.tubes.sock import sock
from pwnlib.timeout import Timeout, TimeoutValue

_Process: TypeAlias = (
    AnyStr | list[AnyStr | bytearray] | tuple[AnyStr | bytearray] | None
)
_Env: TypeAlias = dict[AnyStr, AnyStr] | None

class ssh_channel(sock):
    parent: ssh
    host: str
    returncode: int | None
    tty: bool
    env: _Env
    process: _Process
    cwd: AnyStr
    resizer: Callable[[], None] | None

    def __init__(
        self,
        parent: ssh,
        process: _Process = None,
        tty: bool = False,
        cwd: AnyStr | None = None,
        env: _Env = None,
        raw: bool = True,
        *args: Any,
        **kwargs: Any
    ) -> None: ...
    def kill(self) -> None: ...
    def poll(self, block: bool = ...) -> int | None: ...

class ssh_process(ssh_channel):
    pid: int | None
    uid: int | None
    gid: int | None
    suid: int | None
    sgid: int | None
    argv: _ArgvType
    executable: str | None

    def libs(self) -> dict[str, int]: ...
    @property
    def libc(self) -> ELF | None: ...
    @property
    def elf(self) -> ELF | None: ...
    @property
    def corefile(self) -> Corefile: ...
    def getenv(self, variable: str, **kwargs: Any) -> int: ...

class ssh_connector(sock):
    parent: ssh
    host: str
    rhost: str
    rport: int
    lhost: str
    lport: int

    def __init__(
        self, parent: ssh, host: str, port: int, *args: Any, **kwargs: Any
    ) -> None: ...

class ssh_listener(sock):
    parent: ssh
    host: str
    port: int
    rhost: str | None
    rport: int | None

    def __init__(
        self, parent: ssh, bind_address: str, port: int, *args: Any, **kwargs: Any
    ) -> None: ...
    def wait_for_connection(self) -> ssh_listener: ...

class _SSHRunner:
    @LocalContext
    def __call__(self, *args: _ArgvType) -> bytes: ...

class ssh(Timeout, Logger):
    host: str | None
    port: int | None
    cache: bool
    client: SSHClient
    transport: Transport
    raw: bool

    _cachedir: str
    _tried_sftp: bool

    def __init__(
        self,
        user: str | None = None,
        host: str | None = None,
        port: int = 22,
        password: str | None = None,
        key: None = None,
        keyfile: None = None,
        proxy_command: str | None = None,
        proxy_sock: None = None,
        level: int | ValidLogLevel | None = None,
        cache: bool = True,
        ssh_agent: bool = False,
        ignore_config: bool = False,
        raw: bool = False,
        *args: Any,
        **kwargs: Any
    ) -> None: ...
    @property
    def cwd(self) -> str: ...
    @cwd.setter
    def cwd(self, value: str) -> None: ...
    @property
    def sftp(self) -> SFTPClient | None: ...
    @sftp.setter
    def sftp(self, value: SFTPClient) -> None: ...
    def __enter__(self) -> ssh: ...
    def __exit__(self, *args: Any, **kwargs: Any) -> None: ...
    def shell(
        self, shell: str | None = None, tty: bool = True, timeout: TimeoutValue = ...
    ) -> ssh_channel: ...
    def process(
        self,
        argv: _ArgvType = None,
        executable: str | None = None,
        tty: bool = True,
        cwd: str | None = None,
        env: _Env = None,
        ignore_environ: bool | None = None,
        timeout: TimeoutValue = ...,
        run: bool = True,
        stdin: int = 0,
        stdout: int = 1,
        stderr: int = 2,
        preexec_fn: Callable[[], Any] | None = None,
        preexec_args: tuple[Any] = ...,
        raw: bool = True,
        aslr: bool | None = None,
        setuid: bool | None = None,
        shell: bool = False,
    ) -> ssh_process: ...
    def which(self, program: AnyStr) -> str: ...
    def system(
        self,
        process: _Process,
        tty: bool = True,
        cwd: str | None = None,
        env: _Env = None,
        timeout: TimeoutValue = ...,
        raw: bool = True,
    ) -> ssh_channel: ...
    @deprecated("Use ssh.system instead.")
    def run(
        self,
        process: _Process,
        tty: bool = True,
        cwd: str | None = None,
        env: _Env = None,
        timeout: TimeoutValue = ...,
        raw: bool = True,
    ) -> ssh_channel: ...
    def getenv(self, variable: str, **kwargs: Any) -> int: ...
    def run_to_end(self, process: _Process, tty: bool = False, cwd: str | None = None, env: _Env = None) -> tuple[bytes, int]: ...
    def connect_remote(self, host: str, port: int, timeout: TimeoutValue = ...) -> ssh_connector: ...
    def remote(self, host: str, port: int, timeout: TimeoutValue = ...) -> ssh_connector: ...
    def listen_remote(self, port: int, bind_address: str = ..., timeout: TimeoutValue = ...) -> ssh_listener: ...
    def listen(self, port: int, bind_address: str = ..., timeout: TimeoutValue = ...) -> ssh_listener: ...
    def __getitem__(self, process: str) -> bytes: ...
    def __call__(self, process: str) -> bytes: ...
    def __getattr__(self, process: str) -> _SSHRunner: ...
    def connected(self) -> bool: ...
    def close(self) -> None: ...
    def _libs_remote(self, remote: str) -> dict[str, int]: ...
    def _get_fingerprint(self, remote: AnyStr) -> str | None: ...
    def _get_cachefile(self, fingerprint: str) -> str: ...
    def _verify_local_fingerprint(self, fingerprint: str) -> bool: ...
    def _download_raw(self, remote: str, local: StrOrBytesPath, h: Progress) -> None: ...
    def _download_to_cache(self, remote: str, p: Progress, fingerprint: bool = True) -> str: ...
    def download_data(self, remote: AnyStr, fingerprint: bool = True) -> bytes: ...
    def download_file(self, remote: str, local: StrOrBytesPath | None = None) -> str: ...
    def download_dir(self, remote: str | None, local: StrOrBytesPath | None = None, ignore_failed_read: bool = False) -> None: ...
    def upload_data(self, data: AnyStr, remote: str) -> None: ...
    def upload_file(self, filename: StrOrBytesPath, remote: str | None = None) -> str: ...
    def upload_dir(self, local: StrOrBytesPath, remote: str | None = None) -> None: ...
    def upload(self, file_or_directory: StrOrBytesPath, remote: str | None = None) -> str | None: ...
    def download(self, file_or_directory: AnyStr, local: StrOrBytesPath | None = None) -> str | None: ...
    def put(self, file_or_directory: StrOrBytesPath, remote: str | None = None) -> str | None: ...
    def get(self, file_or_directory: AnyStr, local: StrOrBytesPath | None = None) -> str | None: ...
    def unlink(self, file: str) -> None: ...
    def libs(self, remote: str, directory: str | None = None, flatten: bool = False) -> dict[str, int]: ...
    def interactive(self, shell: str | None) -> None: ...
    def set_working_directory(self, wd: AnyStr | bytearray | None = None, symlink: AnyStr | bool = False) -> str: ...
    def write(self, path: AnyStr, data: AnyStr | bytearray) -> None: ...
    def read(self, path: AnyStr) -> bytes: ...
    def _init_remote_platform_info(self) -> None: ...
    @property
    def os(self) -> str: ...
    @property
    def arch(self) -> str: ...
    @property
    def bits(self) -> int: ...
    @property
    def version(self) -> tuple[int, ...]: ...
    @property
    def distro(self) -> tuple[str, str]: ...
    @property
    def aslr(self) -> bool: ...
    @property
    def aslr_ulimit(self) -> bool: ...
    def _cpuinfo(self) -> bytes: ...
    @property
    def user_shstk(self) -> bool: ...
    @property
    def ibt(self) -> bool: ...
    def _checksec_cache(self, value: str | None = None) -> str | None: ...
    def checksec(self, banner: bool = True) -> str: ...
