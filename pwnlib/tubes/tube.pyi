import re

from collections.abc import Iterable
from typing import Any, AnyStr, Callable
from typing_extensions import overload, Literal, TypeAlias

from pwnlib.log import Logger, ValidLoglevel
from pwnlib.timeout import Timeout, TimeoutValue
from pwnlib.tubes.buffer import Buffer

Predicate: TypeAlias = Callable[[bytes], bool]
Delimiters: TypeAlias = AnyStr | bytearray | Iterable[AnyStr | bytearray]

class tube(Timeout, Logger):
    buffer: Buffer

    def __init__(
        self,
        timeout: TimeoutValue = ...,
        level: int | ValidLoglevel = ...,
        *args: Any,
        **kwargs: Any
    ) -> None: ...
    @property
    def newline(self) -> bytes: ...
    @newline.setter
    def newline(self, newline: AnyStr) -> None: ...
    def recv(self, numb: int, timeout: TimeoutValue = ...) -> bytes: ...
    def read(self, numb: int, timeout: TimeoutValue = ...) -> bytes: ...
    def recvS(self, numb: int, timeout: TimeoutValue = ...) -> str: ...
    def readS(self, numb: int, timeout: TimeoutValue = ...) -> str: ...
    def recvb(self, numb: int, timeout: TimeoutValue = ...) -> bytearray: ...
    def readb(self, numb: int, timeout: TimeoutValue = ...) -> bytearray: ...
    def unrecv(self, data: AnyStr) -> None: ...
    def unread(self, data: AnyStr) -> None: ...
    def recvpred(self, pred: Predicate, timeout: TimeoutValue = ...) -> bytes: ...
    def readpred(self, pred: Predicate, timeout: TimeoutValue = ...) -> bytes: ...
    def recvpredS(self, pred: Predicate, timeout: TimeoutValue = ...) -> str: ...
    def readpredS(self, pred: Predicate, timeout: TimeoutValue = ...) -> str: ...
    def recvpredb(self, pred: Predicate, timeout: TimeoutValue = ...) -> bytearray: ...
    def readpredb(self, pred: Predicate, timeout: TimeoutValue = ...) -> bytearray: ...
    def recvn(self, numb: int, timeout: TimeoutValue = ...) -> bytes: ...
    def readn(self, numb: int, timeout: TimeoutValue = ...) -> bytes: ...
    def recvnS(self, numb: int, timeout: TimeoutValue = ...) -> str: ...
    def readnS(self, numb: int, timeout: TimeoutValue = ...) -> str: ...
    def recvnb(self, numb: int, timeout: TimeoutValue = ...) -> bytearray: ...
    def readnb(self, numb: int, timeout: TimeoutValue = ...) -> bytearray: ...
    def recvuntil(
        self, delims: Delimiters, drop: bool = ..., timeout: TimeoutValue = ...
    ) -> bytes: ...
    def readuntil(
        self, delims: Delimiters, drop: bool = ..., timeout: TimeoutValue = ...
    ) -> bytes: ...
    def recvuntilS(
        self, delims: Delimiters, drop: bool = ..., timeout: TimeoutValue = ...
    ) -> str: ...
    def readuntilS(
        self, delims: Delimiters, drop: bool = ..., timeout: TimeoutValue = ...
    ) -> str: ...
    def recvuntilb(
        self, delims: Delimiters, drop: bool = ..., timeout: TimeoutValue = ...
    ) -> bytearray: ...
    def readuntilb(
        self, delims: Delimiters, drop: bool = ..., timeout: TimeoutValue = ...
    ) -> bytearray: ...
    def recvlines(
        self, numlines: int = ..., keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> list[bytes]: ...
    def readlines(
        self, numlines: int = ..., keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> list[bytes]: ...
    def recvlinesS(
        self, numlines: int = ..., keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> list[str]: ...
    def readlinesS(
        self, numlines: int = ..., keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> list[str]: ...
    def recvlinesb(
        self, numlines: int = ..., keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> list[bytearray]: ...
    def readlinesb(
        self, numlines: int = ..., keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> list[bytearray]: ...
    def recvline(self, keepends: bool = ..., timeout: TimeoutValue = ...) -> bytes: ...
    def readline(self, keepends: bool = ..., timeout: TimeoutValue = ...) -> bytes: ...
    def recvlineS(self, keepends: bool = ..., timeout: TimeoutValue = ...) -> str: ...
    def readlineS(self, keepends: bool = ..., timeout: TimeoutValue = ...) -> str: ...
    def recvlineb(self, keepends: bool = ..., timeout: TimeoutValue = ...) -> bytearray: ...
    def readlineb(self, keepends: bool = ..., timeout: TimeoutValue = ...) -> bytearray: ...
    def recvline_pred(
        self, pred: Predicate, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytes: ...
    def readline_pred(
        self, pred: Predicate, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytes: ...
    def recvline_contains(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytes: ...
    def readline_contains(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytes: ...
    def recvline_containsS(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> str: ...
    def readline_containsS(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> str: ...
    def recvline_containsb(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytearray: ...
    def readline_containsb(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytearray: ...
    def recvline_startswith(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytes: ...
    def readline_startswith(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytes: ...
    def recvline_startswithS(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> str: ...
    def readline_startswithS(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> str: ...
    def recvline_startswithb(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytearray: ...
    def readline_startswithb(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytearray: ...
    def recvline_endswith(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytes: ...
    def readline_endswith(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytes: ...
    def recvline_endswithS(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> str: ...
    def readline_endswithS(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> str: ...
    def recvline_endswithb(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytearray: ...
    def readline_endswithb(
        self, items: Delimiters, keepends: bool = ..., timeout: TimeoutValue = ...
    ) -> bytearray: ...
    # FIXME: recvregexS and recvregexb with capture=True
    @overload
    def recvregex(
        self,
        regex: AnyStr | bytearray | re.Pattern,
        exact: bool = ...,
        timeout: TimeoutValue = ...,
        capture: Literal[True] = True,
    ) -> re.Match | None: ...
    @overload
    def recvregex(
        self, *, exact: bool = ..., timeout: TimeoutValue = ..., capture: Literal[False]
    ) -> bytes: ...
    @overload
    def recvregex(
        self,
        regex: AnyStr | bytearray | re.Pattern,
        exact: bool = ...,
        timeout: TimeoutValue = ...,
        capture: bool = ...,
    ) -> bytes | re.Match | None: ...
    @overload
    def readregex(
        self,
        regex: AnyStr | bytearray | re.Pattern,
        exact: bool = ...,
        timeout: TimeoutValue = ...,
        capture: Literal[True] = True,
    ) -> re.Match | None: ...
    @overload
    def readregex(
        self, *, exact: bool = ..., timeout: TimeoutValue = ..., capture: Literal[False]
    ) -> bytes: ...
    @overload
    def readregex(
        self,
        regex: AnyStr | bytearray | re.Pattern,
        exact: bool = ...,
        timeout: TimeoutValue = ...,
        capture: bool = ...,
    ) -> bytes | re.Match | None: ...
    def recvline_regex(
        self,
        regex: AnyStr | bytearray | re.Pattern,
        exact: bool = ...,
        timeout: TimeoutValue = ...,
    ) -> bytes: ...
    def readline_regex(
        self,
        regex: AnyStr | bytearray | re.Pattern,
        exact: bool = ...,
        timeout: TimeoutValue = ...,
    ) -> bytes: ...
    def recvline_regexS(
        self,
        regex: AnyStr | bytearray | re.Pattern,
        exact: bool = ...,
        timeout: TimeoutValue = ...,
    ) -> str: ...
    def readline_regexS(
        self,
        regex: AnyStr | bytearray | re.Pattern,
        exact: bool = ...,
        timeout: TimeoutValue = ...,
    ) -> str: ...
    def recvline_regexb(
        self,
        regex: AnyStr | bytearray | re.Pattern,
        exact: bool = ...,
        timeout: TimeoutValue = ...,
    ) -> bytearray: ...
    def readline_regexb(
        self,
        regex: AnyStr | bytearray | re.Pattern,
        exact: bool = ...,
        timeout: TimeoutValue = ...,
    ) -> bytearray: ...
    def recvrepeat(self, timeout: TimeoutValue = ...) -> bytes: ...
    def readrepeat(self, timeout: TimeoutValue = ...) -> bytes: ...
    def recvrepeatS(self, timeout: TimeoutValue = ...) -> str: ...
    def readrepeatS(self, timeout: TimeoutValue = ...) -> str: ...
    def recvrepeatb(self, timeout: TimeoutValue = ...) -> bytearray: ...
    def readrepeatb(self, timeout: TimeoutValue = ...) -> bytearray: ...
    def recvall(self, timeout: TimeoutValue = ...) -> bytes: ...
    def readall(self, timeout: TimeoutValue = ...) -> bytes: ...
    def recvallS(self, timeout: TimeoutValue = ...) -> str: ...
    def readallS(self, timeout: TimeoutValue = ...) -> str: ...
    def recvallb(self, timeout: TimeoutValue = ...) -> bytearray: ...
    def readallb(self, timeout: TimeoutValue = ...) -> bytearray: ...
    def send(self, data: AnyStr | bytearray) -> None: ...
    def sendline(self, line: AnyStr | bytearray = ...) -> None: ...
    def sendlines(self, lines: Iterable[AnyStr | bytearray]) -> None: ...
    def sendafter(
        self, delims: Delimiters, data: AnyStr | bytearray, timeout: TimeoutValue = ...
    ) -> bytes: ...
    def sendlineafter(
        self, delims: Delimiters, data: AnyStr | bytearray, timeout: TimeoutValue = ...
    ) -> bytes: ...
    def sendthen(
        self, delims: Delimiters, data: AnyStr | bytearray, timeout: TimeoutValue = ...
    ) -> bytes: ...
    def sendlinethen(
        self, delims: Delimiters, data: AnyStr | bytearray, timeout: TimeoutValue = ...
    ) -> bytes: ...
    def interactive(self, prompt: AnyStr | bytearray = ...) -> None: ...
    def stream(self, line_mode: bool = ...) -> bytes: ...
    def clean(self, timeout: TimeoutValue = ...) -> bytes: ...
    def clean_and_log(self, timeout: TimeoutValue = ...) -> bytes: ...
    def connect_input(self, other: tube) -> None: ...
    def connect_output(self, other: tube) -> None: ...
    def connect_both(self, other: tube) -> None: ...

    # TODO: Add subprocess.Popen arguments?
    def spawn_process(self, *args: Any, **kwargs: Any) -> None: ...
    def __lshift__(self, other: tube) -> None: ...
    def __rshift__(self, other: tube) -> None: ...
    def __ne__(self, other: tube) -> bool: ... # type: ignore
    def wait_for_close(self, timeout: TimeoutValue = ...) -> None: ...
    def wait(self, timeout: TimeoutValue = ...) -> None: ...
    def can_recv(self, timeout: TimeoutValue = ...) -> bool: ...
    def settimeout(self, timeout: TimeoutValue) -> None: ...

    _ShutdownDirections: TypeAlias = Literal[
        "send", "recv", "write", "read", "out", "in"
    ]
    def shutdown(self, direction: _ShutdownDirections = ...) -> None: ...

    _ConnectedDirections: TypeAlias = _ShutdownDirections | Literal["any"]
    def connected(self, direction: _ConnectedDirections = ...) -> bool: ...
    def __enter__(self) -> tube: ...
    def __exit__(self, *a: Any) -> None: ...

    # to be overridden by subclasses
    def recv_raw(self, numb: int) -> bytes: ...
    def send_raw(self, data: AnyStr | bytearray) -> None: ...
    def settimeout_raw(self, timeout: TimeoutValue) -> None: ...
    def can_recv_raw(self, timeout: TimeoutValue = ...) -> bool: ...
    def connected_raw(self, direction: _ConnectedDirections = ...) -> bool: ...
    def close(self) -> None: ...
    def fileno(self) -> int: ...
    def shutdown_raw(self, direction: _ShutdownDirections = ...) -> None: ...

    def p64(self, *a: Any, **kw: Any) -> None: ...
    def p32(self, *a: Any, **kw: Any) -> None: ...
    def p16(self, *a: Any, **kw: Any) -> None: ...
    def p8(self, *a: Any, **kw: Any) -> None: ...
    def pack(self, *a: Any, **kw: Any) -> None: ...

    def u64(self, *a: Any, **kw: Any) -> int: ...
    def u32(self, *a: Any, **kw: Any) -> int: ...
    def u16(self, *a: Any, **kw: Any) -> int: ...
    def u8(self, *a: Any, **kw: Any) -> int: ...
    def unpack(self, *a: Any, **kw: Any) -> int: ...

    def flat(self, *a: Any, **kw: Any) -> None: ...
    def fit(self, *a: Any, **kw: Any) -> None: ...
