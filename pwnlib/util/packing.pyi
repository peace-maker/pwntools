from collections.abc import Iterable
from typing import Any, AnyStr, Callable, BinaryIO, TextIO
from typing_extensions import Literal, Protocol, TypeAlias

from pwnlib.context import LocalNoarchContext

# TODO: Concatenate ContextType properties to kwargs
def pack(
    number: int,
    word_size: int | Literal["all"] | None = ...,
    endianness: Literal["little", "big"] | None = ...,
    sign: bool | None = ...,
    **kwargs: Any
) -> bytes: ...
@LocalNoarchContext
def unpack(
    data: AnyStr | bytearray, word_size: int | Literal["all"] | None = ...
) -> int: ...
@LocalNoarchContext
def unpack_many(
    data: AnyStr, word_size: int | Literal["all"] | None = ...
) -> list[int]: ...
def _p16bs(number: int) -> bytes: ...
def _p16bu(number: int) -> bytes: ...
def _p16ls(number: int) -> bytes: ...
def _p16lu(number: int) -> bytes: ...
def _p32bs(number: int) -> bytes: ...
def _p32bu(number: int) -> bytes: ...
def _p32ls(number: int) -> bytes: ...
def _p32lu(number: int) -> bytes: ...
def _p64bs(number: int) -> bytes: ...
def _p64bu(number: int) -> bytes: ...
def _p64ls(number: int) -> bytes: ...
def _p64lu(number: int) -> bytes: ...
def _p8bs(number: int) -> bytes: ...
def _p8bu(number: int) -> bytes: ...
def _p8ls(number: int) -> bytes: ...
def _p8lu(number: int) -> bytes: ...
def _u16bs(data: AnyStr) -> int: ...
def _u16bu(data: AnyStr) -> int: ...
def _u16ls(data: AnyStr) -> int: ...
def _u16lu(data: AnyStr) -> int: ...
def _u32bs(data: AnyStr) -> int: ...
def _u32bu(data: AnyStr) -> int: ...
def _u32ls(data: AnyStr) -> int: ...
def _u32lu(data: AnyStr) -> int: ...
def _u64bs(data: AnyStr) -> int: ...
def _u64bu(data: AnyStr) -> int: ...
def _u64ls(data: AnyStr) -> int: ...
def _u64lu(data: AnyStr) -> int: ...
def _u8bs(data: AnyStr) -> int: ...
def _u8bu(data: AnyStr) -> int: ...
def _u8ls(data: AnyStr) -> int: ...
def _u8lu(data: AnyStr) -> int: ...
@LocalNoarchContext
def p8(number: int) -> bytes: ...
@LocalNoarchContext
def p16(number: int) -> bytes: ...
@LocalNoarchContext
def p32(number: int) -> bytes: ...
@LocalNoarchContext
def p64(number: int) -> bytes: ...
@LocalNoarchContext
def u8(data: AnyStr) -> int: ...
@LocalNoarchContext
def u16(data: AnyStr) -> int: ...
@LocalNoarchContext
def u32(data: AnyStr) -> int: ...
@LocalNoarchContext
def u64(data: AnyStr) -> int: ...
def make_packer(
    word_size: int | None = ..., sign: bool | None = ..., **kwargs: Any
) -> Callable[[int], bytes]: ...
@LocalNoarchContext
def make_unpacker(word_size: int | None) -> Callable[[AnyStr], int]: ...

class Flatable(Protocol):
    def __flat__(self) -> bytes: ...

FlatableType: TypeAlias = (
    Flatable
    | list[FlatableType]
    | tuple[FlatableType]
    | dict[int | AnyStr | bytearray, FlatableType]
    | AnyStr
    | bytearray
    | int
)

@LocalNoarchContext
def flat(
    *args: FlatableType,
    preprocessor: Callable[[Any], Any | None] = ...,
    filler: Iterable[int] = ...,
    length: int | None = ...,
    stacklevel: int = ...,
    **kwargs: Any
) -> bytes: ...
def fit(*args, **kwargs) -> bytes: ...
def signed(integer: int) -> int: ...
def unsigned(integer: int) -> int: ...

_DDSource: TypeAlias = BinaryIO | TextIO | AnyStr | Iterable[bytes | int]
_DDDestination: TypeAlias = (
    BinaryIO | TextIO | AnyStr | list[bytes] | bytearray | tuple[bytes]
)

def dd(
    dst, src, count: int = ..., skip: int = ..., seek: int = ..., truncate: bool = ...
) -> int: ...

# TODO: Duplicate code from context
class SupportsStr(Protocol):
    def __str__(self) -> str: ...

def _need_bytes(
    s: AnyStr | bytearray, level: int = ..., min_wrong: int = ...
) -> bytes: ...
def _need_text(s: AnyStr | bytearray | SupportsStr, level: int = ...) -> str: ...
def _encode(s: AnyStr | bytearray) -> bytes: ...
def _decode(s: AnyStr | bytearray) -> str: ...
