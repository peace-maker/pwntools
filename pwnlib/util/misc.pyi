from collections.abc import Mapping, Sized
from typing import Any, AnyStr, Callable, Final, Iterable, Protocol
from typing_extensions import TypeAlias
from os import PathLike, StrOrBytesPath

from pwnlib.log import Logger
from pwnlib.tubes.tube import tube

def align(alignment: int, x: int) -> int: ...
def align_down(alignment: int, x: int) -> int: ...
def binary_ip(host: str) -> bytes: ...
def size(n: int | Sized, abbrev: str = ..., si: bool = ...) -> str: ...

KB: Final[int]
MB: Final[int]
GB: Final[int]
KiB: Final[int]
MiB: Final[int]
GiB: Final[int]

def read(path: PathLike, count: int = ..., skip: int = ...) -> bytes: ...
def write(
    path: PathLike, data: bytes = ..., create_dir: bool = ..., mode: str = ...
) -> None: ...

# TODO: overload return type for all=True
def which(
    name: str, all: bool = ..., path: str | None = ...
) -> str | set[str] | None: ...

_Argv: TypeAlias = AnyStr | list[AnyStr | bytearray] | tuple[AnyStr | bytearray]

class _EnvMap(Protocol):
    def values(self) -> Mapping[AnyStr, AnyStr]: ...

_Env: TypeAlias = _EnvMap | Iterable[Iterable[AnyStr]] | None

def normalize_argv_env(
    argv: _Argv | None, env: _Env, log: Logger, level: int = ...
) -> tuple[_Argv, list[tuple[bytearray, bytearray]]]: ...
def run_in_new_terminal(
    command: str,
    terminal: str | None = ...,
    args: list[str] | tuple[str] | None = ...,
    kill_at_exit: bool = ...,
    preexec_fn: Callable[[], Any] | None = ...,
) -> int: ...
def parse_ldd_output(output: str) -> dict[str, int]: ...
def mkdir_p(path: StrOrBytesPath) -> None: ...
def dealarm_shell(tube: tube) -> tube | None: ...
def register_sizes(
    regs: Iterable[str], in_sizes: Iterable[int]
) -> tuple[list[str], dict[str, int], dict[str, list[str]], dict[str, list[str]]]: ...
def python_2_bytes_compatible(klass: type) -> type: ...
