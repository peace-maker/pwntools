from collections.abc import Generator, Iterable, Sequence
from typing import Any, AnyStr, BinaryIO, Callable, Mapping
from typing_extensions import overload, Literal, TypeAlias, TypeVar

from pwnlib.context import LocalNoarchContext

def unhex(s: AnyStr | bytearray) -> bytes: ...
def enhex(x: bytes | bytearray) -> str: ...
def urlencode(s: str) -> str: ...
def urldecode(s: str, ignore_invalid: bool = ...) -> str: ...

_T1 = TypeVar("_T1")
_T2 = TypeVar("_T2")

@overload
def bits(s: bytes | int, *, zero: _T1, one: _T2) -> list[_T1 | _T2]: ...
@overload
def bits(s: bytes | int, *, zero: _T1, one: int = ...) -> list[_T1 | int]: ...
@overload
def bits(s: bytes | int, *, zero: int = ..., one: _T2) -> list[int | _T2]: ...
@overload
def bits(
    s: bytes | int,
    endian: Literal["little", "big"] = ...,
    zero: int = ...,
    one: int = ...,
) -> list[int]: ...
def bits_str(
    s: bytes | int,
    endian: Literal["little", "big"] = ...,
    zero: str = ...,
    one: str = ...,
) -> str: ...
def unbits(
    s: Iterable[Literal[0, 1, "0", "1"] | bool], endian: Literal["little", "big"] = ...
) -> bytes: ...
def bitswap(s: bytes | int) -> bytes: ...
def bitswap_int(n: int, width: int) -> int: ...
def b64e(s: AnyStr | bytearray) -> str: ...
def b64d(s: AnyStr | bytearray) -> bytes: ...
def xor(*args: Any, cur: str | int = ..., **kwargs: Any) -> bytes: ...
def xor_pair(
    data: bytes | int, avoid: AnyStr | bytearray = ...
) -> tuple[bytes, bytes] | None: ...
def xor_key(
    data: bytes | int, avoid: AnyStr | bytearray = ..., size: int | None = ...
) -> tuple[bytes, bytes] | None: ...
def randoms(count: int, alphabet: str = ...) -> str: ...

_RT = TypeVar("_RT", int, bytes, str, Sequence)

def rol(n: _RT, k: int, word_size: int | None = ...) -> _RT: ...
def ror(n: _RT, k: int, word_size: int | None = ...) -> _RT: ...
def naf(n: int) -> Generator[int, None, None]: ...
def isprint(c: int | str) -> bool: ...

# TODO: use packing.flat type
def hexii(s: bytes | bytearray, width: int = ..., skip: bool = ...) -> str: ...

_HexdumpStyle: TypeAlias = Mapping[str, Callable[[str], str]]

def hexdump_iter(
    fd: BinaryIO,
    width: int = ...,
    skip: bool = ...,
    hexii: bool = ...,
    begin: int = ...,
    style: _HexdumpStyle = ...,
    highlight: Iterable[AnyStr] = ...,
    cyclic: bool = ...,
    groupsize: int = ...,
    total: bool = ...,
) -> Generator[str, None, None]: ...

# TODO: use packing.flat type
def hexdump(
    s: AnyStr | bytearray,
    width: int = ...,
    skip: bool = ...,
    hexii: bool = ...,
    begin: int = ...,
    style: _HexdumpStyle = ...,
    highlight: Iterable[AnyStr] = ...,
    cyclic: bool = ...,
    groupsize: int = ...,
    total: bool = ...,
) -> str: ...
def negate(value: int, width: int | None = ...) -> int: ...
def bnot(value: int, width: int | None = ...) -> int: ...
@LocalNoarchContext
def js_escape(data: AnyStr | bytearray, padding: AnyStr = ...) -> str: ...
@LocalNoarchContext
def js_unescape(s: AnyStr | bytearray) -> bytes: ...
